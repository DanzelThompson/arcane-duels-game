<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Arcane Duels - UX Head-to-Head v16</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: Arial, sans-serif;
      background: radial-gradient(circle at top, #252850 0%, #0b0c18 45%, #050509 100%);
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    #game {
      margin-top: 12px;
      margin-bottom: 12px;
      width: 1100px;
      max-width: 95vw;
      border-radius: 16px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(7,7,12,0.98));
      box-shadow:
        0 0 25px rgba(0,0,0,0.7),
        0 0 40px rgba(0, 128, 255, 0.25);
      border: 1px solid rgba(120,160,255,0.4);
      box-sizing: border-box;
    }

    h1 {
      text-align: center;
      font-size: 24px;
      margin: 4px 0 8px 0;
      letter-spacing: 1px;
      color: #e5ecff;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
    }

    .status {
      text-align: center;
      margin-bottom: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(16,20,40,0.96), rgba(8,12,28,0.96));
      border: 1px solid rgba(90,130,220,0.6);
      line-height: 1.4;
      font-size: 13px;
    }

    .status strong {
      color: #8fd5ff;
      font-weight: normal;
    }

    .controls {
      text-align: center;
      margin: 6px 0 10px 0;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(10,12,26,0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      border: 1px solid rgba(60,90,180,0.6);
    }

    .phase-label {
      font-size: 12px;
      color: #e9f0ff;
      padding: 4px 8px;
      border-radius: 999px;
      background: radial-gradient(circle, #303b70 0%, #181d37 50%, #10132b 100%);
      border: 1px solid rgba(130,170,255,0.8);
      box-shadow: 0 0 6px rgba(120,160,255,0.35);
    }

    button {
      font-size: 11px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
      cursor: pointer;
      margin-top: 2px;
      background: #30354b;
      color: #f5f5f5;
      transition:
        background 0.15s ease-out,
        transform 0.08s ease-out,
        box-shadow 0.15s ease-out,
        border-color 0.15s ease-out;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 8px rgba(120,160,255,0.4);
      border-color: rgba(140,180,255,0.8);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .btn-attack {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-color: rgba(255,120,120,0.7);
    }

    .btn-target {
      background: linear-gradient(135deg, #9b59b6, #8e44ad);
      border-color: rgba(192,143,255,0.7);
    }

    .btn-direct {
      background: linear-gradient(135deg, #3498db, #2980b9);
      border-color: rgba(130,190,255,0.7);
    }

    .btn-cancel {
      background: linear-gradient(135deg, #7f8c8d, #5f6a6a);
      border-color: rgba(190,210,210,0.7);
    }

    .btn-ultimate {
      background: linear-gradient(135deg, #f1c40f, #d4ac0d);
      color: #000;
      border-color: rgba(255,230,120,0.7);
    }

    .btn-cast {
      background: linear-gradient(135deg, #16a085, #13866e);
      border-color: rgba(130,245,210,0.7);
    }

    .btn-set {
      background: linear-gradient(135deg, #d35400, #a84300);
      border-color: rgba(255,180,120,0.7);
    }

    .btn-flip {
      background: linear-gradient(135deg, #9b59b6, #8e44ad);
      border-color: rgba(192,143,255,0.7);
    }

    .board-shell {
      display: grid;
      grid-template-rows: auto auto;
      gap: 10px;
    }

    .player-row {
      display: flex;
      justify-content: center;
    }

    .player {
      border-radius: 12px;
      padding: 8px 10px;
      background: radial-gradient(circle at top, #15182d 0%, #0c0e1b 50%, #05060c 100%);
      border: 1px solid rgba(60,90,170,0.7);
      width: 100%;
      max-width: 1000px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
      box-sizing: border-box;
      position: relative;
    }

    .player.current {
      border-color: #4caf50;
      box-shadow:
        0 0 12px rgba(67,160,71,0.7),
        0 0 20px rgba(67,160,71,0.35);
    }

    .player h2 {
      margin: 0 0 4px 0;
      font-size: 16px;
      letter-spacing: 0.5px;
      color: #f8fbff;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
    }

    .player-info-row {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      font-size: 12px;
      color: #d0d4f5;
      margin-bottom: 6px;
    }

    .stat-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 7px;
      border-radius: 999px;
      background: rgba(20,26,52,0.9);
      border: 1px solid rgba(80,115,200,0.7);
      margin: 1px 3px 1px 0;
    }

    .stat-pill span.label {
      color: #9fb9ff;
      font-size: 11px;
    }

    .leader-box {
      margin: 4px 0 6px 0;
      padding: 5px 8px;
      border-radius: 10px;
      background: radial-gradient(circle at left, #20243b 0%, #111426 50%, #0a0c17 100%);
      font-size: 11px;
      border: 1px solid rgba(90,130,210,0.8);
    }

    .leader-title {
      font-size: 12px;
      margin-bottom: 2px;
      color: #c1d3ff;
    }

    .zone-label {
      font-size: 11px;
      margin: 4px 0 2px 0;
      color: #a9b4dd;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .lane-note {
      font-size: 10px;
      margin-bottom: 3px;
      color: #8c93bd;
    }

    .zones,
    .hand,
    .back-row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 2px;
    }

    .zones::-webkit-scrollbar,
    .hand::-webkit-scrollbar,
    .back-row::-webkit-scrollbar,
    .log-box::-webkit-scrollbar {
      height: 4px;
      width: 5px;
    }

    .zones::-webkit-scrollbar-thumb,
    .hand::-webkit-scrollbar-thumb,
    .back-row::-webkit-scrollbar-thumb,
    .log-box::-webkit-scrollbar-thumb {
      background: rgba(120,150,220,0.6);
      border-radius: 999px;
    }

    .card-slot {
      background: linear-gradient(145deg, #181b2a, #10131e);
      border-radius: 10px;
      padding: 6px;
      min-width: 150px;
      max-width: 170px;
      font-size: 11px;
      border: 1px solid rgba(60,80,140,0.8);
      position: relative;
      box-shadow: 0 2px 6px rgba(0,0,0,0.7);
      box-sizing: border-box;
      transition:
        transform 0.12s ease-out,
        box-shadow 0.12s ease-out,
        border-color 0.15s ease-out,
        background 0.15s ease-out;
    }

    .card-slot:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.9);
      border-color: rgba(140,180,255,1);
    }

    .card-slot.empty {
      color: #b4bad5;
      text-align: center;
      font-style: italic;
      border-style: dashed;
      border-color: rgba(80,100,160,0.7);
      background: radial-gradient(circle, #161824 0%, #10121d 50%, #0a0c15 100%);
    }

    .card-title {
      font-size: 12px;
      margin-bottom: 2px;
      padding: 2px 4px;
      border-radius: 6px;
      background: linear-gradient(135deg, #31365a, #232843);
      color: #f7fbff;
      text-align: left;
    }

    .card-title.monster {
      background: linear-gradient(135deg, #3b7bd6, #2b4b9b);
    }

    .card-title.spell {
      background: linear-gradient(135deg, #16a085, #0e6b57);
    }

    .card-title.trap {
      background: linear-gradient(135deg, #9b59b6, #6d3c85);
    }

    .card-stats {
      font-size: 11px;
      margin: 2px 0 2px 0;
      color: #dbe4ff;
    }

    .card-text {
      font-size: 10px;
      margin-bottom: 4px;
      color: #aeb5d9;
      line-height: 1.3;
    }

    .lane-label-small {
      font-size: 10px;
      color: #8a90b6;
      margin-bottom: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .lane-label-small span {
      color: #c8d4ff;
    }

    .selected-indicator {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #4caf50;
      color: #fff;
      font-size: 9px;
      padding: 2px 4px;
      border-radius: 999px;
      box-shadow: 0 0 6px rgba(76,175,80,0.9);
    }

    .has-attacked {
      opacity: 0.6;
    }

    .log-box {
      margin-top: 10px;
      padding: 6px 8px;
      border-radius: 10px;
      background: radial-gradient(circle at top, #121426 0%, #0a0c16 50%, #05060c 100%);
      border: 1px solid rgba(70,90,160,0.9);
      max-height: 150px;
      overflow-y: auto;
      font-size: 11px;
    }

    .log-entry {
      margin-bottom: 2px;
      color: #ced6ff;
    }

    .small-note {
      text-align: center;
      font-size: 11px;
      color: #9aa3d0;
      margin-top: 6px;
      line-height: 1.4;
    }

    .ai-note {
      font-size: 11px;
      color: #d9a6ff;
    }
  </style>
</head>
<body>
  <div id="game-wrapper">
    <h1>Arcane Duels</h1>
    <div id="game"></div>
  </div>

  <script>
    const vsAI = true;
    const HUMAN_PLAYER = 0;
    const AI_PLAYER = 1;

    const baseMonsters = [
      { id: "ember_scout", type: "monster", name: "Ember Scout", cost: 1, attack: 2, health: 1, text: "Fast little attacker. Great on turn 1." },
      { id: "flame_rookie", type: "monster", name: "Flameblade Rookie", cost: 2, attack: 3, health: 2, text: "Solid early beater. Trades up in combat." },
      { id: "verdant_guard", type: "monster", name: "Verdant Guardian", cost: 2, attack: 1, health: 4, text: "Tanky blocker. Soaks hits to protect your Life." },
      { id: "iron_defender", type: "monster", name: "Iron Legion Defender", cost: 3, attack: 2, health: 4, text: "Mid-game body. Good on both attack and defense." },
      { id: "storm_titan", type: "monster", name: "Stormcaller Titan", cost: 5, attack: 5, health: 5, text: "Big finisher. Hard to remove once it lands." }
    ];

    const extraDeckMonsters = [
      { id: "last_stand_vanguard", type: "monster", name: "Last Stand Vanguard", cost: 3, attack: 4, health: 3, text: "Last Stand unit. Comes out swinging hard." },
      { id: "phoenix_fallen", type: "monster", name: "Phoenix of the Fallen", cost: 5, attack: 4, health: 4, text: "Rises when your main deck is gone." },
      { id: "despair_titan", type: "monster", name: "Titan of Despair", cost: 6, attack: 6, health: 6, text: "Massive Last Stand finisher." },
      { id: "soul_reclaimer", type: "monster", name: "Soul Reclaimer", cost: 4, attack: 2, health: 5, text: "Thrives on the Souls of fallen allies." },
      { id: "edgewalker_assassin", type: "monster", name: "Edgewalker Assassin", cost: 2, attack: 3, health: 1, text: "Last Stand striker, fragile but deadly." }
    ];

    const spellCards = [
      {
        id: "arcane_bolt",
        type: "spell",
        name: "Arcane Bolt",
        cost: 2,
        text: "Cost: 2 Mana. Deal 2 damage to a target enemy monster.",
        effect: "arcane_bolt"
      },
      {
        id: "battle_cry",
        type: "spell",
        name: "Battle Cry",
        cost: 2,
        text: "Cost: 2 Mana. All your monsters gain +1 ATK permanently.",
        effect: "battle_cry"
      },
      {
        id: "soul_lance",
        type: "spell",
        name: "Soul Lance",
        cost: 1,
        soulsCost: 2,
        text: "Cost: 1 Mana + 2 Souls. Deal 3 damage to a target enemy monster.",
        effect: "soul_lance"
      }
    ];

    const trapCards = [
      {
        id: "mirror_strike",
        type: "trap",
        name: "Mirror Strike",
        cost: 2,
        text: "Cost: 2 Mana. Flip in Battle: destroy a target enemy monster.",
        effect: "mirror_strike"
      },
      {
        id: "soulburst_shield",
        type: "trap",
        name: "Soulburst Shield",
        cost: 1,
        soulsCost: 1,
        text: "Cost: 1 Mana + 1 Soul. Flip in Battle: give one of your monsters +1 ATK and +2 HP.",
        effect: "soulburst_shield"
      }
    ];

    function createLeader() {
      return {
        id: "arena_warlord",
        name: "Arena Warlord",
        passive: "Passive: Future versions may give lane-based buffs. For now, your Ultimate is your main power.",
        ultimateDesc: "Ultimate (once per game): Give all your monsters +1 ATK.",
        ultimateUsed: false
      };
    }

    let game = null;
    let selectedAttacker = null;

    function logMessage(text) {
      if (!game) return;
      if (!game.log) game.log = [];
      game.log.push(text);
      if (game.log.length > 30) {
        game.log.shift();
      }
    }

    function costString(card) {
      const mana = card.cost || 0;
      const souls = card.soulsCost || 0;
      if (souls > 0) return mana + " Mana, " + souls + " Souls";
      return mana + " Mana";
    }

    function laneName(index) {
      switch (index) {
        case 0: return "Lane 1 – Guard";
        case 1: return "Lane 2 – Neutral";
        case 2: return "Lane 3 – Arena";
        case 3: return "Lane 4 – Neutral";
        case 4: return "Lane 5 – Direct";
        default: return "Lane";
      }
    }

    function laneEmptyLabel(index) {
      switch (index) {
        case 0: return "Guard Lane (+1 HP on summon)";
        case 1: return "Neutral Lane";
        case 2: return "Arena Lane (+1 ATK on summon)";
        case 3: return "Neutral Lane";
        case 4: return "Direct Lane (can hit Life even if enemy has monsters)";
        default: return "Empty";
      }
    }

    function phaseName(phase) {
      if (phase === "MAIN1") return "Main Phase 1";
      if (phase === "BATTLE") return "Battle Phase";
      if (phase === "MAIN2") return "Main Phase 2";
      return phase;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function createMainDeck() {
      const deck = [];
      const mainMonsters = baseMonsters.slice(0, 4);
      for (let copies = 0; copies < 4; copies++) {
        mainMonsters.forEach(card => deck.push({ ...card }));
      }
      for (let copies = 0; copies < 2; copies++) {
        deck.push({ ...baseMonsters[4] });
      }
      for (let i = 0; i < 3; i++) deck.push({ ...spellCards[0] });
      for (let i = 0; i < 3; i++) deck.push({ ...spellCards[1] });
      for (let i = 0; i < 2; i++) deck.push({ ...spellCards[2] });
      for (let i = 0; i < 2; i++) deck.push({ ...trapCards[0] });
      for (let i = 0; i < 2; i++) deck.push({ ...trapCards[1] });
      return shuffle(deck);
    }

    function createExtraDeck() {
      const deck = [];
      extraDeckMonsters.forEach(card => deck.push({ ...card }));
      return shuffle(deck);
    }

    function addCardToHand(player, card) {
      if (player.hand.length >= 5) return;
      player.hand.push(card);
    }

    function gainSoul(playerIndex) {
      const p = game.players[playerIndex];
      p.souls = Math.min(10, p.souls + 1);
    }

    function enterLastStand(player) {
      if (player.lastStand) return;
      player.lastStand = true;
      logMessage(player.name + " entered LAST STAND! Their monsters gain +1 ATK.");
      alert(player.name + " has entered LAST STAND! Their monsters gain +1 ATK.");
      player.board.forEach(card => {
        if (card) card.attack += 1;
      });
    }

    function restartGame() {
      const firstPlayer = Math.random() < 0.5 ? 0 : 1;

      game = {
        players: [
          {
            name: "Player 1 (Bottom)",
            health: 20,
            deck: createMainDeck(),
            extraDeck: createExtraDeck(),
            hand: [],
            board: [null, null, null, null, null],
            backRow: [null, null, null, null, null],
            manaCap: 1,
            mana: 1,
            souls: 0,
            lastStand: false,
            leader: createLeader()
          },
          {
            name: "Player 2 (Top) [AI]",
            health: 20,
            deck: createMainDeck(),
            extraDeck: createExtraDeck(),
            hand: [],
            board: [null, null, null, null, null],
            backRow: [null, null, null, null, null],
            manaCap: 1,
            mana: 1,
            souls: 0,
            lastStand: false,
            leader: createLeader()
          }
        ],
        currentPlayer: firstPlayer,
        firstPlayer: firstPlayer,
        turnNumber: 1,
        gameOver: false,
        phase: "MAIN1",
        log: []
      };

      selectedAttacker = null;

      for (let i = 0; i < 4; i++) {
        drawCard(0);
        drawCard(1);
      }

      startTurn(game.currentPlayer);
      renderGame();

      if (vsAI && game.currentPlayer === AI_PLAYER && !game.gameOver) {
        setTimeout(runAITurn, 300);
      }
    }

    function drawCard(playerIndex) {
      const p = game.players[playerIndex];
      if (p.deck.length > 0) {
        const card = p.deck.pop();
        addCardToHand(p, card);
      } else if (p.extraDeck.length > 0) {
        if (!p.lastStand) enterLastStand(p);
        const card = p.extraDeck.pop();
        addCardToHand(p, card);
      } else {
        p.health = 0;
        checkWin();
      }
    }

    function startTurn(playerIndex) {
      if (game.gameOver) return;
      const p = game.players[playerIndex];

      p.board.forEach(card => {
        if (card) card.hasAttacked = false;
      });

      p.manaCap = Math.min(10, game.turnNumber);
      p.mana = p.manaCap;
      game.phase = "MAIN1";
      drawCard(playerIndex);
      selectedAttacker = null;
      logMessage(p.name + " starts their turn with " + p.manaCap + " mana.");
    }

    function canCurrentPlayerAttack() {
      if (game.gameOver) return false;
      if (game.phase !== "BATTLE") return false;
      if (game.turnNumber === 1 && game.currentPlayer === game.firstPlayer) return false;
      return true;
    }

    function endTurnInternal() {
      if (game.gameOver) return;
      selectedAttacker = null;
      game.currentPlayer = 1 - game.currentPlayer;
      game.turnNumber += 1;
      startTurn(game.currentPlayer);
      renderGame();
    }

    function endTurnButton() {
      if (game.gameOver) return;
      const prev = game.currentPlayer;
      endTurnInternal();
      if (vsAI && prev === HUMAN_PLAYER && game.currentPlayer === AI_PLAYER && !game.gameOver) {
        setTimeout(runAITurn, 300);
      }
    }

    function goToBattlePhase() {
      if (game.gameOver) return;
      if (game.phase !== "MAIN1") return;
      game.phase = "BATTLE";
      selectedAttacker = null;
      logMessage(game.players[game.currentPlayer].name + " entered Battle Phase.");
      renderGame();
      if (vsAI && game.currentPlayer === HUMAN_PLAYER) {
        aiUseTrapsAtStartOfBattle(HUMAN_PLAYER, AI_PLAYER);
      }
    }

    function goToMain2() {
      if (game.gameOver) return;
      if (game.phase !== "BATTLE") return;
      game.phase = "MAIN2";
      selectedAttacker = null;
      logMessage(game.players[game.currentPlayer].name + " entered Main Phase 2.");
      renderGame();
    }

    function playCardToLane(playerIndex, handIndex, slotIndex) {
      if (game.gameOver) return;
      const p = game.players[playerIndex];

      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) {
        if (playerIndex === HUMAN_PLAYER) alert("You can only play monsters during Main Phases.");
        return;
      }

      const card = p.hand[handIndex];
      if (!card || card.type !== "monster") return;

      if (p.mana < card.cost) {
        if (playerIndex === HUMAN_PLAYER) alert("Not enough mana to play this card.");
        return;
      }

      if (slotIndex < 0 || slotIndex > 4) return;
      if (p.board[slotIndex] !== null) {
        if (playerIndex === HUMAN_PLAYER) alert("That lane is already occupied.");
        return;
      }

      p.mana -= card.cost;

      const newMonster = {
        id: card.id,
        type: "monster",
        name: card.name,
        cost: card.cost,
        attack: card.attack,
        health: card.health,
        text: card.text,
        hasAttacked: false
      };

      if (slotIndex === 0) newMonster.health += 1;
      else if (slotIndex === 2) newMonster.attack += 1;
      if (p.lastStand) newMonster.attack += 1;

      p.board[slotIndex] = newMonster;
      p.hand.splice(handIndex, 1);
      renderGame();
    }

    function useLeaderUltimate(playerIndex) {
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) {
        if (playerIndex === HUMAN_PLAYER) alert("You can only use your leader's ultimate on your turn.");
        return;
      }

      const p = game.players[playerIndex];
      if (p.leader.ultimateUsed) {
        if (playerIndex === HUMAN_PLAYER) alert("You already used your leader's ultimate.");
        return;
      }

      p.board.forEach(card => {
        if (card) card.attack += 1;
      });

      p.leader.ultimateUsed = true;
      logMessage(p.name + " used their Ultimate. All their monsters gain +1 ATK.");
      renderGame();
    }

    function onHandDragStart(ev, playerIndex, handIndex) {
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) return;
      if (playerIndex !== HUMAN_PLAYER) return;
      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) return;

      const p = game.players[playerIndex];
      const card = p.hand[handIndex];
      if (!card || card.type !== "monster") return;

      const payload = { playerIndex, handIndex };
      ev.dataTransfer.setData("text/plain", JSON.stringify(payload));
    }

    function onBoardDragOver(ev, playerIndex, slotIndex) {
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) return;
      if (playerIndex !== HUMAN_PLAYER) return;
      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) return;
      ev.preventDefault();
    }

    function onBoardDrop(ev, playerIndex, slotIndex) {
      ev.preventDefault();
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) return;
      if (playerIndex !== HUMAN_PLAYER) return;
      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) return;

      const dataStr = ev.dataTransfer.getData("text/plain");
      if (!dataStr) return;

      let data;
      try { data = JSON.parse(dataStr); } catch { return; }
      if (data.playerIndex !== playerIndex) return;
      playCardToLane(data.playerIndex, data.handIndex, slotIndex);
    }

    function castSpell(playerIndex, handIndex) {
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) return;
      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) {
        if (playerIndex === HUMAN_PLAYER) alert("You can only cast spells during Main Phases.");
        return;
      }

      const p = game.players[playerIndex];
      const card = p.hand[handIndex];
      if (!card || card.type !== "spell") return;

      if (p.mana < card.cost) {
        if (playerIndex === HUMAN_PLAYER) alert("Not enough mana to cast this spell.");
        return;
      }
      if (card.soulsCost && p.souls < card.soulsCost) {
        if (playerIndex === HUMAN_PLAYER) alert("Not enough Souls to cast this spell.");
        return;
      }

      const opponentIndex = 1 - playerIndex;
      const opponent = game.players[opponentIndex];

      if (card.effect === "battle_cry") {
        p.mana -= card.cost;
        if (card.soulsCost) p.souls -= card.soulsCost;
        p.board.forEach(m => { if (m) m.attack += 1; });
        logMessage(p.name + " cast Battle Cry. Their monsters gain +1 ATK.");
        p.hand.splice(handIndex, 1);
        renderGame();
        return;
      }

      if (card.effect === "arcane_bolt" || card.effect === "soul_lance") {
        const dmg = card.effect === "arcane_bolt" ? 2 : 3;

        const laneStr = prompt(card.name + ": choose enemy monster lane (1-5) to target:");
        if (laneStr === null) return;
        const laneIdx = parseInt(laneStr, 10) - 1;
        if (isNaN(laneIdx) || laneIdx < 0 || laneIdx > 4) {
          if (playerIndex === HUMAN_PLAYER) alert("Invalid lane.");
          return;
        }

        const target = opponent.board[laneIdx];
        if (!target) {
          if (playerIndex === HUMAN_PLAYER) alert("No enemy monster in that lane.");
          return;
        }

        if (p.mana < card.cost) {
          if (playerIndex === HUMAN_PLAYER) alert("Not enough mana anymore to cast this spell.");
          return;
        }
        if (card.soulsCost && p.souls < card.soulsCost) {
          if (playerIndex === HUMAN_PLAYER) alert("Not enough Souls anymore to cast this spell.");
          return;
        }

        p.mana -= card.cost;
        if (card.soulsCost) p.souls -= card.soulsCost;

        target.health -= dmg;
        let soulNote = card.soulsCost ? " (spent " + card.soulsCost + " Souls)" : "";
        logMessage(p.name + " cast " + card.name + " on Lane " + (laneIdx + 1) + " for " + dmg + " damage." + soulNote);

        if (target.health <= 0) {
          opponent.board[laneIdx] = null;
          gainSoul(opponentIndex);
          logMessage(game.players[opponentIndex].name + "'s monster in Lane " + (laneIdx + 1) + " was destroyed.");
        }

        p.hand.splice(handIndex, 1);
        checkWin();
        renderGame();
        return;
      }
    }

    function setTrap(playerIndex, handIndex) {
      if (game.gameOver) return;
      if (playerIndex !== game.currentPlayer) return;
      if (!(game.phase === "MAIN1" || game.phase === "MAIN2")) {
        if (playerIndex === HUMAN_PLAYER) alert("You can only set traps during Main Phases.");
        return;
      }

      const p = game.players[playerIndex];
      const card = p.hand[handIndex];
      if (!card || card.type !== "trap") return;

      const slotIndex = p.backRow.findIndex(s => s === null);
      if (slotIndex === -1) {
        if (playerIndex === HUMAN_PLAYER) alert("No empty Spell/Trap zone.");
        return;
      }

      p.backRow[slotIndex] = {
        id: card.id,
        type: "trap",
        name: card.name,
        cost: card.cost || 0,
        soulsCost: card.soulsCost || 0,
        text: card.text,
        effect: card.effect,
        faceDown: true
      };

      logMessage(p.name + " set a trap.");
      p.hand.splice(handIndex, 1);
      renderGame();
    }

    function activateTrap(playerIndex, slotIndex) {
      if (game.gameOver) return false;
      if (game.phase !== "BATTLE") {
        if (playerIndex === HUMAN_PLAYER) alert("You can only flip traps during Battle Phase.");
        return false;
      }

      const p = game.players[playerIndex];
      const trap = p.backRow[slotIndex];
      if (!trap || trap.type !== "trap") return false;

      const opponentIndex = 1 - playerIndex;
      const opponent = game.players[opponentIndex];

      if (playerIndex === HUMAN_PLAYER) {
        if (trap.effect === "mirror_strike") {
          const laneStr = prompt("Mirror Strike: choose enemy monster lane (1-5) to destroy:");
          if (laneStr === null) return false;
          const laneIdx = parseInt(laneStr, 10) - 1;
          if (isNaN(laneIdx) || laneIdx < 0 || laneIdx > 4) {
            alert("Invalid lane.");
            return false;
          }
          const target = opponent.board[laneIdx];
          if (!target) {
            alert("No enemy monster in that lane.");
            return false;
          }

          if (p.mana < trap.cost) {
            alert("Not enough mana to activate this trap.");
            return false;
          }
          if (trap.soulsCost && p.souls < trap.soulsCost) {
            alert("Not enough Souls to activate this trap.");
            return false;
          }
          p.mana -= trap.cost;
          if (trap.soulsCost) p.souls -= trap.soulsCost;

          opponent.board[laneIdx] = null;
          gainSoul(opponentIndex);
          let soulNote = trap.soulsCost ? " (spent " + trap.soulsCost + " Souls)" : "";
          logMessage(p.name + " activated Mirror Strike on Lane " + (laneIdx + 1) + "." + soulNote);
          p.backRow[slotIndex] = null;
          checkWin();
          renderGame();
          return true;
        }

        if (trap.effect === "soulburst_shield") {
          const laneStr = prompt("Soulburst Shield: choose your monster lane (1-5) to protect/buff:");
          if (laneStr === null) return false;
          const laneIdx = parseInt(laneStr, 10) - 1;
          if (isNaN(laneIdx) || laneIdx < 0 || laneIdx > 4) {
            alert("Invalid lane.");
            return false;
          }
          const target = p.board[laneIdx];
          if (!target) {
            alert("You have no monster in that lane.");
            return false;
          }

          if (p.mana < trap.cost) {
            alert("Not enough mana to activate this trap.");
            return false;
          }
          if (trap.soulsCost && p.souls < trap.soulsCost) {
            alert("Not enough Souls to activate this trap.");
            return false;
          }
          p.mana -= trap.cost;
          if (trap.soulsCost) p.souls -= trap.soulsCost;

          target.attack += 1;
          target.health += 2;
          let soulNote = trap.soulsCost ? " (spent " + trap.soulsCost + " Souls)" : "";
          logMessage(p.name + " activated Soulburst Shield on their monster in Lane " + (laneIdx + 1) + "." + soulNote);
          p.backRow[slotIndex] = null;
          renderGame();
          return true;
        }
      }
      return false;
    }

    function humanTrapResponseWindow() {
      if (game.gameOver) return;
      if (game.phase !== "BATTLE") return;
      if (game.currentPlayer !== AI_PLAYER) return;

      const p = game.players[HUMAN_PLAYER];
      const hasTrap = p.backRow.some(st => st && st.type === "trap");
      if (!hasTrap) return;

      const want = confirm("AI is in Battle Phase. Do you want to activate one of your traps? (OK = Yes, Cancel = No)");
      if (!want) return;

      const slotStr = prompt("Choose one of your trap slots (1-5) to flip, or 0 to cancel:");
      if (slotStr === null) return;
      const slotNum = parseInt(slotStr, 10);
      if (isNaN(slotNum) || slotNum < 0 || slotNum > 5) {
        alert("Invalid slot.");
        return;
      }
      if (slotNum === 0) return;
      const idx = slotNum - 1;
      const trap = p.backRow[idx];
      if (!trap || trap.type !== "trap") {
        alert("No trap in that slot.");
        return;
      }

      activateTrap(HUMAN_PLAYER, idx);
    }

    function chooseAttacker(slotIndex) {
      if (game.gameOver) return;
      if (!canCurrentPlayerAttack()) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("You can only attack during Battle Phase, and the starting player cannot attack on turn 1.");
        return;
      }

      const pIndex = game.currentPlayer;
      const p = game.players[pIndex];
      const card = p.board[slotIndex];

      if (!card) return;
      if (card.hasAttacked) {
        if (pIndex === HUMAN_PLAYER) alert("This monster has already attacked this turn.");
        return;
      }

      selectedAttacker = { playerIndex: pIndex, slotIndex };
      renderGame();
    }

    function attackMonster(defenderSlotIndex) {
      if (game.gameOver) return;
      if (!selectedAttacker) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("Select an attacker first.");
        return;
      }

      if (!canCurrentPlayerAttack()) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("You can only attack during Battle Phase, and the starting player cannot attack on turn 1.");
        return;
      }

      const attackerIndex = selectedAttacker.playerIndex;
      const defenderIndex = 1 - attackerIndex;

      if (game.currentPlayer !== attackerIndex) {
        if (attackerIndex === HUMAN_PLAYER) alert("It's not your turn.");
        return;
      }

      const attackerPlayer = game.players[attackerIndex];
      const defenderPlayer = game.players[defenderIndex];

      const atkCard = attackerPlayer.board[selectedAttacker.slotIndex];
      const defCard = defenderPlayer.board[defenderSlotIndex];

      if (!atkCard || atkCard.hasAttacked) {
        if (attackerIndex === HUMAN_PLAYER) alert("That attacker is no longer available.");
        selectedAttacker = null;
        renderGame();
        return;
      }

      if (!defCard) {
        if (attackerIndex === HUMAN_PLAYER) alert("No monster in that slot to attack.");
        return;
      }

      defCard.health -= atkCard.attack;
      atkCard.health -= defCard.attack;

      if (defCard.health <= 0) {
        defenderPlayer.board[defenderSlotIndex] = null;
        gainSoul(defenderIndex);
        logMessage(attackerPlayer.name + "'s " + atkCard.name + " destroyed a monster in Lane " + (defenderSlotIndex + 1) + ".");
      }

      if (atkCard.health <= 0) {
        attackerPlayer.board[selectedAttacker.slotIndex] = null;
        gainSoul(attackerIndex);
        logMessage(attackerPlayer.name + "'s " + atkCard.name + " was destroyed in combat.");
      } else {
        atkCard.hasAttacked = true;
      }

      selectedAttacker = null;
      checkWin();
      renderGame();
    }

    function attackLifeDirect() {
      if (game.gameOver) return;
      if (!selectedAttacker) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("Select an attacker first.");
        return;
      }

      if (!canCurrentPlayerAttack()) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("You can only attack during Battle Phase, and the starting player cannot attack on turn 1.");
        return;
      }

      const attackerIndex = selectedAttacker.playerIndex;
      const defenderIndex = 1 - attackerIndex;

      if (game.currentPlayer !== attackerIndex) {
        if (attackerIndex === HUMAN_PLAYER) alert("It's not your turn.");
        return;
      }

      const attackerPlayer = game.players[attackerIndex];
      const defenderPlayer = game.players[defenderIndex];

      const atkCard = attackerPlayer.board[selectedAttacker.slotIndex];
      if (!atkCard || atkCard.hasAttacked) {
        if (attackerIndex === HUMAN_PLAYER) alert("That attacker is no longer available.");
        selectedAttacker = null;
        renderGame();
        return;
      }

      const laneIndex = selectedAttacker.slotIndex;
      const defenderHasMonsters = defenderPlayer.board.some(c => c !== null);

      if (defenderHasMonsters && laneIndex !== 4) {
        if (attackerIndex === HUMAN_PLAYER) alert("You cannot attack directly while your opponent controls monsters, except from the Direct Lane (Lane 5).");
        return;
      }

      defenderPlayer.health -= atkCard.attack;
      logMessage(attackerPlayer.name + "'s " + atkCard.name + " attacked " + defenderPlayer.name + " directly for " + atkCard.attack + " damage.");
      atkCard.hasAttacked = true;
      selectedAttacker = null;

      checkWin();
      renderGame();
    }

    function attackAllDirect() {
      if (game.gameOver) return;
      if (!canCurrentPlayerAttack()) {
        if (game.currentPlayer === HUMAN_PLAYER) alert("You can only attack during Battle Phase, and the starting player cannot attack on turn 1.");
        return;
      }

      const attackerIndex = game.currentPlayer;
      const defenderIndex = 1 - attackerIndex;

      const attackerPlayer = game.players[attackerIndex];
      const defenderPlayer = game.players[defenderIndex];

      const defenderHasMonsters = defenderPlayer.board.some(c => c !== null);
      if (defenderHasMonsters) {
        if (attackerIndex === HUMAN_PLAYER) alert("You cannot use 'Attack with all directly' while your opponent controls monsters.");
        return;
      }

      const readyAttackers = attackerPlayer.board.filter(card => card && !card.hasAttacked);
      if (readyAttackers.length === 0) {
        if (attackerIndex === HUMAN_PLAYER) alert("You have no monsters that can attack directly.");
        return;
      }

      let totalDamage = 0;
      readyAttackers.forEach(card => {
        defenderPlayer.health -= card.attack;
        totalDamage += card.attack;
        card.hasAttacked = true;
      });

      logMessage(attackerPlayer.name + " attacked directly with all monsters for " + totalDamage + " total damage.");
      selectedAttacker = null;
      checkWin();
      renderGame();
    }

    function cancelSelection() {
      selectedAttacker = null;
      renderGame();
    }

    function checkWin() {
      const p0 = game.players[0];
      const p1 = game.players[1];

      if (p0.health <= 0 && p1.health <= 0) {
        p0.health = Math.max(0, p0.health);
        p1.health = Math.max(0, p1.health);
        game.gameOver = true;
        logMessage("Draw! Both players reached 0 Life or decked out.");
        alert("Draw! Both players reached 0 Life or decked out.");
      } else if (p0.health <= 0) {
        p0.health = 0;
        game.gameOver = true;
        logMessage(p1.name + " wins!");
        alert(p1.name + " wins!");
      } else if (p1.health <= 0) {
        p1.health = 0;
        game.gameOver = true;
        logMessage(p0.name + " wins!");
        alert(p0.name + " wins!");
      }
    }

    function runAITurn() {
      if (!vsAI || game.gameOver) return;
      if (game.currentPlayer !== AI_PLAYER) return;

      const p = game.players[AI_PLAYER];
      game.phase = "MAIN1";
      renderGame();
      logMessage(p.name + " (AI) is taking its turn.");

      aiMainPhasePlay();

      if (!p.leader.ultimateUsed && p.board.filter(c => c).length >= 2) {
        useLeaderUltimate(AI_PLAYER);
      }

      if (!game.gameOver) goToBattlePhase();
      if (!game.gameOver) aiUseTrapsAtStartOfBattle(AI_PLAYER, HUMAN_PLAYER);
      if (!game.gameOver) aiBattlePhaseActions();
      if (!game.gameOver && game.phase === "BATTLE") goToMain2();
      if (!game.gameOver) endTurnInternal();
    }

    function aiMainPhasePlay() {
      const p = game.players[AI_PLAYER];
      let safety = 0;

      while (safety < 10) {
        safety++;
        let playedSomething = false;

        let playableMonsters = [];
        p.hand.forEach((card, idx) => {
          if (card.type === "monster" && card.cost <= p.mana) {
            playableMonsters.push({ card, idx });
          }
        });

        if (playableMonsters.length > 0 && p.board.some(slot => slot === null)) {
          playableMonsters.sort((a, b) => a.card.cost - b.card.cost);
          const choice = playableMonsters[0];
          let lane = p.board.findIndex(slot => slot === null);
          if (lane === -1) lane = 0;
          playCardToLane(AI_PLAYER, choice.idx, lane);
          playedSomething = true;
        } else {
          const emptyST = p.backRow.findIndex(s => s === null);
          if (emptyST !== -1) {
            const trapIndex = p.hand.findIndex(c => c.type === "trap");
            if (trapIndex !== -1) {
              setTrap(AI_PLAYER, trapIndex);
              playedSomething = true;
            }
          }
        }

        if (!playedSomething) {
          const bcIndex = p.hand.findIndex(
            c => c.type === "spell" && c.effect === "battle_cry" && c.cost <= p.mana
          );
          if (bcIndex !== -1 && p.board.filter(c => c).length >= 2) {
            castSpell(AI_PLAYER, bcIndex);
            playedSomething = true;
          }
        }

        if (!playedSomething) break;
      }
    }

    function aiUseTrapsAtStartOfBattle(attackerIndex, defenderIndex) {
      if (!vsAI) return;
      if (defenderIndex !== AI_PLAYER) return;
      if (game.phase !== "BATTLE") return;

      const p = game.players[AI_PLAYER];
      const opp = game.players[attackerIndex];

      for (let i = 0; i < 5; i++) {
        const trap = p.backRow[i];
        if (!trap || trap.type !== "trap") continue;
        if (trap.effect !== "mirror_strike") continue;
        if (p.mana < trap.cost) continue;
        if (trap.soulsCost && p.souls < trap.soulsCost) continue;

        let targetLane = -1;
        let bestAtk = -1;
        for (let lane = 0; lane < 5; lane++) {
          const m = opp.board[lane];
          if (m && m.attack > bestAtk) {
            bestAtk = m.attack;
            targetLane = lane;
          }
        }
        if (targetLane === -1) continue;

        p.mana -= trap.cost;
        if (trap.soulsCost) p.souls -= trap.soulsCost;

        opp.board[targetLane] = null;
        gainSoul(attackerIndex);
        let soulNote = trap.soulsCost ? " (spent " + trap.soulsCost + " Souls)" : "";
        logMessage(p.name + " activated Mirror Strike and destroyed " + opp.name + "'s monster in Lane " + (targetLane + 1) + "." + soulNote);
        p.backRow[i] = null;
        renderGame();
        return;
      }

      for (let i = 0; i < 5; i++) {
        const trap = p.backRow[i];
        if (!trap || trap.type !== "trap") continue;
        if (trap.effect !== "soulburst_shield") continue;
        if (p.mana < trap.cost) continue;
        if (trap.soulsCost && p.souls < trap.soulsCost) continue;

        let targetLane = -1;
        for (let lane = 0; lane < 5; lane++) {
          if (p.board[lane]) {
            targetLane = lane;
            break;
          }
        }
        if (targetLane === -1) continue;

        p.mana -= trap.cost;
        if (trap.soulsCost) p.souls -= trap.soulsCost;

        p.board[targetLane].attack += 1;
        p.board[targetLane].health += 2;
        let soulNote = trap.soulsCost ? " (spent " + trap.soulsCost + " Souls)" : "";
        logMessage(p.name + " activated Soulburst Shield to buff its monster in Lane " + (targetLane + 1) + "." + soulNote);
        p.backRow[i] = null;
        renderGame();
        return;
      }
    }

    function aiBattlePhaseActions() {
      if (!canCurrentPlayerAttack()) return;

      const p = game.players[AI_PLAYER];
      const opp = game.players[HUMAN_PLAYER];

      for (let i = 0; i < 5; i++) {
        if (game.gameOver) break;

        humanTrapResponseWindow();
        if (game.gameOver) break;

        const card = p.board[i];
        if (!card || card.hasAttacked) continue;
        if (!canCurrentPlayerAttack()) break;

        const defenderHasMonsters = opp.board.some(c => c !== null);

        if (!defenderHasMonsters) {
          selectedAttacker = { playerIndex: AI_PLAYER, slotIndex: i };
          attackLifeDirect();
        } else {
          if (opp.board[i]) {
            selectedAttacker = { playerIndex: AI_PLAYER, slotIndex: i };
            attackMonster(i);
          } else if (i === 4) {
            selectedAttacker = { playerIndex: AI_PLAYER, slotIndex: i };
            attackLifeDirect();
          } else {
            const targetIdx = opp.board.findIndex(c => c !== null);
            if (targetIdx !== -1) {
              selectedAttacker = { playerIndex: AI_PLAYER, slotIndex: i };
              attackMonster(targetIdx);
            }
          }
        }
      }
    }

    function renderGame() {
      const container = document.getElementById("game");
      let html = "";

      html += `
        <div class="status">
          Turn ${game.turnNumber} |
          Current Player: ${game.players[game.currentPlayer].name} |
          Starting Player (coin toss): ${game.players[game.firstPlayer].name} |
          ${game.gameOver ? "Game Over" : "In Progress"}
          <br>
          Phases: Main 1 → Battle → Main 2. You can play monsters, spells, and traps in Main 1 and Main 2.
        </div>
      `;

      html += renderControls();

      html += `<div class="board-shell">`;
      html += `<div class="player-row">${renderPlayer(1)}</div>`;
      html += `<div class="player-row">${renderPlayer(0)}</div>`;
      html += `</div>`;

      html += `<div class="log-box">`;
      html += `<div style="margin-bottom:4px;">Game log:</div>`;
      if (game.log && game.log.length > 0) {
        game.log.forEach(entry => {
          html += `<div class="log-entry">• ${entry}</div>`;
        });
      } else {
        html += `<div class="log-entry">No actions yet.</div>`;
      }
      html += `</div>`;

      html += `
        <div class="small-note">
          Monsters: drag from your hand (bottom player) onto empty lanes during Main 1 or Main 2.
          <br>
          Spells: cast via the Cast button in your hand during Main Phases.
          Traps: setting is free; cost is paid only when you flip them in Battle.
          <br>
          Lane 1 = Guard (+1 HP on summon), Lane 3 = Arena (+1 ATK on summon), Lane 5 = Direct (can attack Life even if enemy has monsters).
          <br>
          <span class="ai-note">AI: Top player. It will play cards, use its Ultimate, and may flip traps defensively during Battle.</span>
        </div>
      `;

      container.innerHTML = html;
    }

    function renderPlayer(index) {
      const p = game.players[index];
      const isCurrent = game.currentPlayer === index;
      const isDefenderOfSelection = selectedAttacker && selectedAttacker.playerIndex === (1 - index);

      let html = `<div class="player ${isCurrent ? "current" : ""}">`;

      html += `<div class="player-info-row">
        <div>
          <h2>${p.name} ${isCurrent ? "(current turn)" : ""}</h2>
          <div>
            <span class="stat-pill"><span class="label">Life</span> ${p.health}</span>
            <span class="stat-pill"><span class="label">Mana</span> ${p.mana}/${p.manaCap}</span>
            <span class="stat-pill"><span class="label">Souls</span> ${p.souls}/10</span>
          </div>
        </div>
        <div style="text-align:right;">
          <div>
            <span class="stat-pill"><span class="label">Deck</span> ${p.deck.length}</span>
            <span class="stat-pill"><span class="label">Extra</span> ${p.extraDeck.length}</span>
            <span class="stat-pill"><span class="label">Hand</span> ${p.hand.length}/5</span>
          </div>
          <div style="margin-top:3px;">
            <span class="stat-pill"><span class="label">Last Stand</span> ${p.lastStand ? "ON" : "OFF"}</span>
          </div>
        </div>
      </div>`;

      html += `<div class="leader-box">
        <div class="leader-title">Leader: ${p.leader.name}</div>
        <div>${p.leader.passive}</div>
        <div>${p.leader.ultimateDesc}</div>
      `;
      const isThisHuman = index === HUMAN_PLAYER;
      if (isThisHuman && isCurrent && !p.leader.ultimateUsed && !game.gameOver) {
        html += `<div style="margin-top:4px;"><button class="btn-ultimate" onclick="useLeaderUltimate(${index})">Use Ultimate</button></div>`;
      } else if (p.leader.ultimateUsed) {
        html += `<div style="font-size:11px;color:#ced4ff;margin-top:2px;">Ultimate used.</div>`;
      }
      html += `</div>`;

      /* ORDERING DIFFERENCE:
         - AI (top): Hand → Spell/Trap Row → Monster Row
         - Human (bottom): Monster Row → Spell/Trap Row → Hand
      */

      if (index === AI_PLAYER) {
        /* AI HAND ON TOP */
        html += `<div class="zone-label">Hand (${p.hand.length}/5)</div>`;
        html += `<div class="hand">`;
        p.hand.forEach((card, idx) => {
          const isCurrentTurn = isCurrent && !game.gameOver;
          const inMainPhase = game.phase === "MAIN1" || game.phase === "MAIN2";
          let dragAttrs = "";

          /* AI never drags cards, so dragAttrs stays empty */

          const cStr = costString(card);
          let typeClass = "";
          if (card.type === "monster") typeClass = "monster";
          else if (card.type === "spell") typeClass = "spell";
          else if (card.type === "trap") typeClass = "trap";

          html += `<div class="card-slot" ${dragAttrs}>`;
          html += `<div class="card-title ${typeClass}">${card.name}</div>`;
          html += `<div class="card-stats">Cost: ${cStr}</div>`;

          if (card.type === "monster") {
            html += `<div class="card-stats">ATK ${card.attack} / HP ${card.health}</div>`;
            html += `<div class="card-text">Monster – ${card.text}</div>`;
          } else if (card.type === "spell") {
            html += `<div class="card-text">Spell – ${card.text}</div>`;
          } else if (card.type === "trap") {
            html += `<div class="card-text">Trap – ${card.text}</div>`;
          }
          html += `</div>`;
        });
        if (p.hand.length === 0) {
          html += `<div class="card-slot empty">No cards in hand</div>`;
        }
        html += `</div>`;

        /* Spell/Trap row in the middle for AI */
        html += `<div class="zone-label">Spell / Trap Row</div>`;
        html += `<div class="back-row">`;
        for (let i = 0; i < 5; i++) {
          const st = p.backRow[i];
          if (!st) {
            html += `
              <div class="card-slot empty">
                S/T Slot ${i + 1}<br>${laneEmptyLabel(i)}
              </div>
            `;
          } else if (st.type === "trap") {
            const cStr = costString(st);
            const canFlip = !game.gameOver && game.phase === "BATTLE" && index === HUMAN_PLAYER;
            html += `
              <div class="card-slot">
                <div class="lane-label-small"><span>S/T Slot ${i + 1}</span></div>
                <div class="card-title trap">${st.name}</div>
                <div class="card-stats">Cost: ${cStr}</div>
                <div class="card-text">Trap – ${st.text}</div>
                ${
                  canFlip
                    ? `<button class="btn-flip" onclick="activateTrap(${index}, ${i})">Flip / Activate</button>`
                    : `<div style="font-size:11px;color:#ccc;">Face-down trap (can be flipped in Battle)</div>`
                }
              </div>
            `;
          } else {
            html += `<div class="card-slot">Unknown S/T</div>`;
          }
        }
        html += `</div>`;

        /* Monster row closest to center */
        html += `<div class="zone-label">Monster Row</div>`;
        html += `<div class="lane-note">
          Lane 1 = Guard, Lane 3 = Arena, Lane 5 = Direct.
        </div>`;
        html += renderMonsterRow(index, p, isCurrent, isDefenderOfSelection);
      } else {
        /* HUMAN (BOTTOM): monster → S/T → hand (this was already middle-row S/T) */
        html += `<div class="zone-label">Monster Row</div>`;
        html += `<div class="lane-note">
          Lane 1 = Guard, Lane 3 = Arena, Lane 5 = Direct.
        </div>`;
        html += renderMonsterRow(index, p, isCurrent, isDefenderOfSelection);

        html += `<div class="zone-label">Spell / Trap Row</div>`;
        html += `<div class="back-row">`;
        for (let i = 0; i < 5; i++) {
          const st = p.backRow[i];
          if (!st) {
            html += `
              <div class="card-slot empty">
                S/T Slot ${i + 1}<br>${laneEmptyLabel(i)}
              </div>
            `;
          } else if (st.type === "trap") {
            const cStr = costString(st);
            const canFlip = !game.gameOver && game.phase === "BATTLE" && index === HUMAN_PLAYER;
            html += `
              <div class="card-slot">
                <div class="lane-label-small"><span>S/T Slot ${i + 1}</span></div>
                <div class="card-title trap">${st.name}</div>
                <div class="card-stats">Cost: ${cStr}</div>
                <div class="card-text">Trap – ${st.text}</div>
                ${
                  canFlip
                    ? `<button class="btn-flip" onclick="activateTrap(${index}, ${i})">Flip / Activate</button>`
                    : `<div style="font-size:11px;color:#ccc;">Face-down trap (can be flipped in Battle)</div>`
                }
              </div>
            `;
          } else {
            html += `<div class="card-slot">Unknown S/T</div>`;
          }
        }
        html += `</div>`;

        html += `<div class="zone-label">Hand (${p.hand.length}/5)</div>`;
        html += `<div class="hand">`;
        p.hand.forEach((card, idx) => {
          const isCurrentTurn = isCurrent && !game.gameOver;
          const inMainPhase = game.phase === "MAIN1" || game.phase === "MAIN2";
          let dragAttrs = "";

          if (
            isCurrentTurn &&
            inMainPhase &&
            card.type === "monster" &&
            index === HUMAN_PLAYER
          ) {
            dragAttrs = `draggable="true" ondragstart="onHandDragStart(event, ${index}, ${idx})"`;
          }

          const cStr = costString(card);
          let typeClass = "";
          if (card.type === "monster") typeClass = "monster";
          else if (card.type === "spell") typeClass = "spell";
          else if (card.type === "trap") typeClass = "trap";

          html += `<div class="card-slot" ${dragAttrs}>`;
          html += `<div class="card-title ${typeClass}">${card.name}</div>`;
          html += `<div class="card-stats">Cost: ${cStr}</div>`;

          if (card.type === "monster") {
            html += `<div class="card-stats">ATK ${card.attack} / HP ${card.health}</div>`;
            html += `<div class="card-text">Monster – ${card.text}</div>`;
          } else if (card.type === "spell") {
            html += `<div class="card-text">Spell – ${card.text}</div>`;
            if (index === HUMAN_PLAYER && isCurrentTurn && inMainPhase) {
              html += `<button class="btn-cast" onclick="castSpell(${index}, ${idx})">Cast</button>`;
            }
          } else if (card.type === "trap") {
            html += `<div class="card-text">Trap – ${card.text}</div>`;
            if (index === HUMAN_PLAYER && isCurrentTurn && inMainPhase) {
              html += `<button class="btn-set" onclick="setTrap(${index}, ${idx})">Set</button>`;
            }
          }
          html += `</div>`;
        });
        if (p.hand.length === 0) {
          html += `<div class="card-slot empty">No cards in hand</div>`;
        }
        html += `</div>`;
      }

      html += `</div>`;
      return html;
    }

    function renderMonsterRow(index, p, isCurrent, isDefenderOfSelection) {
      let html = `<div class="zones">`;
      for (let i = 0; i < 5; i++) {
        const card = p.board[i];
        const allowDrop =
          index === HUMAN_PLAYER &&
          isCurrent &&
          !game.gameOver &&
          (game.phase === "MAIN1" || game.phase === "MAIN2") &&
          card === null;

        if (card) {
          const isSelected =
            selectedAttacker &&
            selectedAttacker.playerIndex === index &&
            selectedAttacker.slotIndex === i;

          const cardClasses = ["card-slot"];
          if (card.hasAttacked && index === game.currentPlayer) cardClasses.push("has-attacked");

          html += `
            <div class="${cardClasses.join(" ")}">
              <div class="lane-label-small"><span>${laneName(i)}</span></div>
              ${isSelected ? `<div class="selected-indicator">Selected</div>` : ""}
              <div class="card-title monster">${card.name}</div>
              <div class="card-stats">ATK ${card.attack} / HP ${card.health} | Cost: ${card.cost} Mana</div>
              <div class="card-text">${card.text}</div>
          `;

          if (
            index === HUMAN_PLAYER &&
            isCurrent &&
            !card.hasAttacked &&
            !game.gameOver &&
            canCurrentPlayerAttack()
          ) {
            html += `<button class="btn-attack" onclick="chooseAttacker(${i})">Attack</button>`;
          }

          if (isDefenderOfSelection && !game.gameOver) {
            html += `<button class="btn-target" onclick="attackMonster(${i})">Target</button>`;
          }

          html += `</div>`;
        } else {
          const dropAttrs = allowDrop
            ? `ondragover="onBoardDragOver(event, ${index}, ${i})" ondrop="onBoardDrop(event, ${index}, ${i})"`
            : "";
          html += `
            <div class="card-slot empty" ${dropAttrs}>
              <div class="lane-label-small"><span>${laneName(i)}</span></div>
              ${laneEmptyLabel(i)}
            </div>
          `;
        }
      }
      html += `</div>`;
      return html;
    }

    function renderControls() {
      let html = `<div class="controls">`;
      html += `<span class="phase-label">Phase: ${phaseName(game.phase)}</span>`;

      if (!game.gameOver) {
        if (game.phase === "MAIN1" && game.currentPlayer === HUMAN_PLAYER) {
          html += `<button onclick="goToBattlePhase()">Battle Phase</button>`;
        } else if (game.phase === "BATTLE" && game.currentPlayer === HUMAN_PLAYER) {
          html += `<button onclick="goToMain2()">Main Phase 2</button>`;
        }

        if (game.currentPlayer === HUMAN_PLAYER) {
          html += `<button onclick="endTurnButton()">End turn</button>`;
        } else {
          html += `<span class="ai-note">AI turn in progress...</span>`;
        }

        html += `<button onclick="restartGame()">Restart game</button>`;

        if (game.currentPlayer === HUMAN_PLAYER && canCurrentPlayerAttack()) {
          const current = game.players[game.currentPlayer];
          const opponent = game.players[1 - game.currentPlayer];
          const defenderHasMonsters = opponent.board.some(c => c !== null);
          const hasReadyAttackers = current.board.some(card => card && !card.hasAttacked);

          if (!defenderHasMonsters && hasReadyAttackers) {
            html += `<button class="btn-direct" onclick="attackAllDirect()">Attack with all directly</button>`;
          }
        }

        if (game.currentPlayer === HUMAN_PLAYER && selectedAttacker && canCurrentPlayerAttack()) {
          html += `<button class="btn-direct" onclick="attackLifeDirect()">Attack Life (if allowed)</button>`;
          html += `<button class="btn-cancel" onclick="cancelSelection()">Cancel selection</button>`;
        } else if (selectedAttacker && !canCurrentPlayerAttack()) {
          if (game.currentPlayer === HUMAN_PLAYER) {
            html += `<button class="btn-cancel" onclick="cancelSelection()">Cancel selection</button>`;
          }
        }
      } else {
        html += `<button onclick="restartGame()">Restart game</button>`;
      }

      html += `</div>`;
      return html;
    }

    window.onload = restartGame;
  </script>
</body>
</html>
